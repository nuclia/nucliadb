# Copyright (C) 2021 Bosutech XXI S.L.
#
# nucliadb is offered under the AGPL v3.0 and as commercial software.
# For commercial licensing, contact us at info@nuclia.com.
#
# AGPL:
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

from base64 import b64decode, b64encode
from enum import Enum
from typing import Optional

from google.protobuf.message import DecodeError, Message
from pydantic import BaseModel, ConfigDict, Field, field_validator
from typing_extensions import TypedDict

from nucliadb_models.search import Image
from nucliadb_protos.resources_pb2 import FieldMetadata, FieldText, QuestionAnswers


class FieldInfo(BaseModel):
    """
    Model to represent the field information required
    """

    text: str = Field(..., title="The text of the field")
    metadata: str = Field(
        title="The metadata of the field as a base64 string serialized nucliadb_protos.resources.FieldMetadata protobuf",
    )
    field_id: str = Field(
        ...,
        title="The field ID of the field (rid/field_type/field[/split]) or any unique identifier",
    )


class OperationType(str, Enum):
    graph = "graph"
    label = "label"
    ask = "ask"
    qa = "qa"
    extract = "extract"
    prompt_guard = "prompt_guard"
    llama_guard = "llama_guard"


class NameOperationFilter(BaseModel):
    operation_type: OperationType = Field(..., description="Type of the operation")
    task_names: list[str] = Field(
        default_factory=list,
        description="list of task names. If None or empty, all tasks for that operation are applied.",
    )


class RunAgentsRequest(BaseModel):
    """
    Model to represent a request for the Augment model
    The text will be augmented with the Knowledge Box's configured Data Augmentation Agents
    """

    fields: list[FieldInfo] = Field(
        ...,
        title="The fields to be augmented with the Knowledge Box's Data Augmentation Agents",
    )
    user_id: str = Field(..., title="The user ID of the user making the request")
    agent_ids: list[str] = Field(
        default_factory=list,
        title="An optional list of Data Augmentation Agent IDs to run. If empty, all configured agents that match the filters are run.",
    )
    filters: Optional[list[NameOperationFilter]] = Field(
        default=None,
        title="Filters to select which Data Augmentation Agents are applied to the text. If empty, all configured agents for the Knowledge Box are applied.",
    )


class NewTextField(TypedDict):
    text_field: FieldText
    destination: str


class AppliedDataAugmentation(BaseModel):
    model_config = ConfigDict(
        # Since we have protos as fields, we need to enable arbitrary_types_allowed
        arbitrary_types_allowed=True,
    )
    qas: Optional[QuestionAnswers] = Field(
        default=None,
        description="Question and answers generated by the Question Answers agent",
    )
    new_text_fields: list[NewTextField] = Field(
        default_factory=list,
        description="New text fields. Only generated by the Labeler agent as of now.",
    )
    changed: bool = Field(
        default=True,
        description="Indicates if the FieldMetadata was changed by the agents",
    )

    @field_validator("qas", mode="before")
    def validate_qas(cls, qas: Optional[str]) -> Optional[QuestionAnswers]:
        if qas is None:
            return None
        try:
            return QuestionAnswers.FromString(b64decode(qas))
        except DecodeError:
            raise ValueError("Invalid QuestionAnswers protobuf")

    @field_validator("new_text_fields", mode="before")
    def validate_new_text_fields(cls, new_text_fields: list[NewTextField]) -> list[NewTextField]:
        try:
            return [
                NewTextField(
                    text_field=FieldText.FromString(b64decode(text_field["text_field"])),  # type: ignore
                    destination=text_field["destination"],
                )
                for text_field in new_text_fields
            ]
        except DecodeError:
            raise ValueError("Invalid NewTextField value")


class AugmentedField(BaseModel):
    # Since we have protos as fields, we need to enable arbitrary_types_allowed
    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        # Custom encoding to be able to serialize protobuf messages
        json_encoders={Message: lambda m: b64encode(m.SerializeToString()).decode()},
    )
    metadata: FieldMetadata = Field(
        ...,
        title="The updated metadata of the field as a base64 string serialized nucliadb_protos.resources.FieldMetadata protobuf",
    )
    applied_data_augmentation: AppliedDataAugmentation = Field(
        ..., title="The results of the Applied Data Augmentation"
    )
    input_nuclia_tokens: float = Field(
        ..., title="The number of input Nuclia tokens consumed for the field"
    )
    output_nuclia_tokens: float = Field(
        ..., title="The number of output Nuclia tokens consumed for the field"
    )
    time: float = Field(..., title="The time taken to execute the Data Augmentation agents to the field")

    @field_validator("metadata", mode="before")
    def validate_metadata(cls, metadata: str) -> FieldMetadata:
        try:
            return FieldMetadata.FromString(b64decode(metadata))
        except DecodeError:
            raise ValueError("Invalid FieldMetadata protobuf")


class RunAgentsResponse(BaseModel):
    results: dict[str, AugmentedField] = Field(
        ...,
        title="Pairs of augmented FieldMetadata and Data Augmentation results by field id",
    )


class QueryModel(BaseModel):
    """
    Model to represent a query request
    """

    text: Optional[str] = Field(default=None, description="The query text to be processed")
    query_image: Optional[Image] = Field(
        default=None,
        description="Image to be considered as part of the query.  Even if the `rephrase` parameter is set to `false`, the rephrasing process will occur, combining the provided text with the image's visual features in the rephrased query.",
    )
    rephrase: bool = Field(
        default=False,
        description="If true, the model will rephrase the input text before processing",
    )
    rephrase_prompt: Optional[str] = Field(
        default=None,
        description="Custom prompt for rephrasing the input text",
        examples=[
            """Rephrase this question so its better for retrieval, and keep the rephrased question in the same language as the original.
QUESTION: {question}
Please return ONLY the question without any explanation. Just the rephrased question.""",
            """Rephrase this question so its better for retrieval, if in the image there are any machinery components with numeric identifiers, append them to the end of the question separated by a commas.
QUESTION: {question}
Please return ONLY the question without any explanation.""",
        ],
    )
    generative_model: Optional[str] = Field(
        default=None,
        description="The generative model to use for rephrasing",
    )
    semantic_models: Optional[list[str]] = Field(
        default=None,
        description="Semantic models to compute the sentence vector for, if not provided, it will only compute the sentence vector for default semantic model in the Knowledge box's configuration.",
    )
    agentic_entities: bool = Field(
        default=False,
        description="If true, the model will return the entities detected in the sentence guided by an already defined Graph Extraction Agent in the Knowledge Box.",
    )
