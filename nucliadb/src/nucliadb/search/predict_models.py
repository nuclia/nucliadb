# Copyright (C) 2021 Bosutech XXI S.L.
#
# nucliadb is offered under the AGPL v3.0 and as commercial software.
# For commercial licensing, contact us at info@nuclia.com.
#
# AGPL:
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

from base64 import b64decode, b64encode
from enum import Enum
from typing import Optional, TypedDict

from google.protobuf.message import DecodeError, Message
from pydantic import BaseModel, ConfigDict, Field, field_validator

from nucliadb_protos.resources_pb2 import FieldMetadata, FieldText, QuestionAnswers


class FieldInfo(BaseModel):
    """
    Model to represent the field information required
    """

    text: str = Field(..., title="The text of the field")
    metadata: str = Field(
        title="The metadata of the field as a base64 string serialized nucliadb_protos.resources.FieldMetadata protobuf",
    )
    field_id: str = Field(
        ...,
        title="The field ID of the field (rid/field_type/field[/split]) or any unique identifier",
    )


class OperationType(str, Enum):
    graph = "graph"
    label = "label"
    ask = "ask"
    qa = "qa"
    extract = "extract"
    prompt_guard = "prompt_guard"
    llama_guard = "llama_guard"


class NameOperationFilter(BaseModel):
    operation_type: OperationType = Field(..., description="Type of the operation")
    task_names: list[str] = Field(
        default_factory=list,
        description="list of task names. If None or empty, all tasks for that operation are applied.",
    )


class RunAgentsRequest(BaseModel):
    """
    Model to represent a request for the Augment model
    The text will be augmented with the Knowledge Box's configured Data Augmentation Agents
    """

    fields: list[FieldInfo] = Field(
        ...,
        title="The fields to be augmented with the Knowledge Box's Data Augmentation Agents",
    )
    user_id: str = Field(..., title="The user ID of the user making the request")
    filters: Optional[list[NameOperationFilter]] = Field(
        default=None,
        title="Filters to select which Data Augmentation Agents are applied to the text. If empty, all configured agents for the Knowledge Box are applied.",
    )


class NewTextField(TypedDict):
    text_field: FieldText
    destination: str


class AppliedDataAugmentation(BaseModel):
    model_config = ConfigDict(
        # Since we have protos as fields, we need to enable arbitrary_types_allowed
        arbitrary_types_allowed=True,
    )
    qas: Optional[QuestionAnswers] = Field(
        default=None,
        description="Question and answers generated by the Question Answers agent",
    )
    new_text_fields: list[NewTextField] = Field(
        default_factory=list,
        description="New text fields. Only generated by the Labeler agent as of now.",
    )
    changed: bool = Field(
        default=True,
        description="Indicates if the FieldMetadata was changed by the agents",
    )

    @field_validator("qas", mode="before")
    def validate_qas(cls, qas: Optional[str]) -> Optional[QuestionAnswers]:
        if qas is None:
            return None
        try:
            return QuestionAnswers.FromString(b64decode(qas))
        except DecodeError:
            raise ValueError("Invalid QuestionAnswers protobuf")

    @field_validator("new_text_fields", mode="before")
    def validate_new_text_fields(cls, new_text_fields: list[NewTextField]) -> list[NewTextField]:
        try:
            return [
                NewTextField(
                    text_field=FieldText.FromString(b64decode(text_field["text_field"])),  # type: ignore
                    destination=text_field["destination"],
                )
                for text_field in new_text_fields
            ]
        except DecodeError:
            raise ValueError("Invalid NewTextField value")


class AugmentedField(BaseModel):
    # Since we have protos as fields, we need to enable arbitrary_types_allowed
    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        # Custom encoding to be able to serialize protobuf messages
        json_encoders={Message: lambda m: b64encode(m.SerializeToString()).decode()},
    )
    metadata: FieldMetadata = Field(
        ...,
        title="The updated metadata of the field as a base64 string serialized nucliadb_protos.resources.FieldMetadata protobuf",
    )
    applied_data_augmentation: AppliedDataAugmentation = Field(
        ..., title="The results of the Applied Data Augmentation"
    )
    input_nuclia_tokens: float = Field(
        ..., title="The number of input Nuclia tokens consumed for the field"
    )
    output_nuclia_tokens: float = Field(
        ..., title="The number of output Nuclia tokens consumed for the field"
    )
    time: float = Field(..., title="The time taken to execute the Data Augmentation agents to the field")

    @field_validator("metadata", mode="before")
    def validate_metadata(cls, metadata: str) -> FieldMetadata:
        try:
            return FieldMetadata.FromString(b64decode(metadata))
        except DecodeError:
            raise ValueError("Invalid FieldMetadata protobuf")


class RunAgentsResponse(BaseModel):
    results: dict[str, AugmentedField] = Field(
        ...,
        title="Pairs of augmented FieldMetadata and Data Augmentation results by field id",
    )
