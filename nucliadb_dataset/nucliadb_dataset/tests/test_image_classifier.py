# Copyright (C) 2021 Bosutech XXI S.L.
#
# nucliadb is offered under the AGPL v3.0 and as commercial software.
# For commercial licensing, contact us at info@nuclia.com.
#
# AGPL:
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

import base64
import json
import os
import tempfile
import time

import pyarrow as pa  # type: ignore
import pytest
from grpc import aio
from nucliadb_protos.dataset_pb2 import TaskType, TrainSet
from nucliadb_protos.resources_pb2 import (
    CloudFile,
    FileExtractedData,
    FilePages,
    PageStructure,
    PageStructurePage,
    PageStructureToken,
)
from nucliadb_protos.writer_pb2 import BrokerMessage, OpStatusWriter
from nucliadb_protos.writer_pb2_grpc import WriterStub

from nucliadb_dataset.dataset import NucliaDBDataset
from nucliadb_models.metadata import UserFieldMetadata
from nucliadb_models.resource import KnowledgeBoxConfig
from nucliadb_sdk.knowledgebox import KnowledgeBox
from nucliadb_sdk.tests.fixtures import NucliaFixture
from nucliadb_sdk.v2.sdk import NucliaDB, Region

_dir = os.path.dirname(__file__)
_testdata_dir = os.path.join(
    _dir, "..", "..", "..", "nucliadb", "nucliadb", "tests", "testdata"
)


INVOICE_FILENAME = os.path.join(_testdata_dir, "invoice.pdf")
INVOICE_SELECTIONS_FILENAME = os.path.join(_testdata_dir, "invoice_selections.json")


def test_image_classification(
    knowledgebox: KnowledgeBox, image_classification_resource
):
    trainset = TrainSet()
    trainset.type = TaskType.IMAGE_CLASSIFICATION

    with tempfile.TemporaryDirectory() as tmpdirname:
        dataset = NucliaDBDataset(
            client=knowledgebox.client,
            trainset=trainset,
            base_path=tmpdirname,
        )
        partitions = dataset.get_partitions()
        assert len(partitions) == 1

        # TODO: remove after ticket sc-4488 is fixed
        time.sleep(1)

        filename = dataset.read_partition(partitions[0])

        with pa.memory_map(filename, "rb") as source:
            loaded_array = pa.ipc.open_stream(source).read_all()

            resource_count = 1
            fields_per_resource = 2  # file and autogenerated title
            assert len(loaded_array) == resource_count * fields_per_resource


@pytest.fixture
@pytest.mark.asyncio
async def image_classification_resource(
    sdk_v2: NucliaDB, nucliadb_grpc: WriterStub, kb: KnowledgeBoxConfig
):
    kbid = kb.uuid
    field_id = "invoice"

    with open(INVOICE_SELECTIONS_FILENAME) as f:
        selections = json.load(f)

    fieldmetadata = generate_image_classification_fieldmetadata(selections, field_id)

    with open(INVOICE_FILENAME, "rb") as f:
        invoice_content = f.read()

    resource = sdk_v2.create_resource(
        kbid=kbid,
        **{
            "title": "My invoice",
            "files": {
                field_id: {
                    "file": {
                        "filename": "invoice.pdf",
                        "content_type": "application/pdf",
                        "payload": base64.b64encode(invoice_content).decode(),
                    }
                }
            },
            "fieldmetadata": fieldmetadata,
        },
    )

    broker_message = generate_image_classification_broker_message(
        selections, kbid, resource.uuid, field_id
    )
    resp = await nucliadb_grpc.ProcessMessage(
        [broker_message], timeout=10, wait_for_ready=True
    )
    assert resp.status == OpStatusWriter.Status.OK


@pytest.fixture(scope="function")
def sdk_v2(nucliadb: NucliaFixture) -> NucliaDB:
    url = f"{nucliadb.url}"
    yield NucliaDB(
        region=Region.ON_PREM,
        url=url,
    )


@pytest.fixture(scope="function")
@pytest.mark.asyncio
async def nucliadb_grpc(nucliadb: NucliaFixture) -> NucliaDB:
    address = f"{nucliadb.host}:{nucliadb.grpc}"
    channel = aio.insecure_channel(address)
    yield WriterStub(channel)


@pytest.fixture
def kb(sdk_v2: NucliaDB) -> KnowledgeBoxConfig:
    import random

    salt = str(random.random())[2:]
    kb = sdk_v2.create_knowledge_box(slug=f"image-classification-kb-{salt}")
    yield kb
    sdk_v2.delete_knowledge_box(kbid=kb.uuid)


def generate_image_classification_fieldmetadata(
    selections: dict, field_id: str
) -> list[UserFieldMetadata]:
    selections_by_page = {}
    for annotation in selections["annotations"]:
        page_selections = selections_by_page.setdefault(annotation["page"], [])
        page_selections.append(
            {
                "label": annotation["label"]["text"],
                "top": annotation["bounds"]["top"],
                "left": annotation["bounds"]["left"],
                "right": annotation["bounds"]["right"],
                "bottom": annotation["bounds"]["bottom"],
                "token_ids": [token["tokenIndex"] for token in annotation["tokens"]],
            }
        )

    fieldmetadata = {
        "field": {"field": field_id, "field_type": "file"},
        "selections": [
            {
                "page": page,
                "visual": selections,
            }
            for page, selections in selections_by_page.items()
        ],
    }
    return [fieldmetadata]


def generate_image_classification_broker_message(
    selections: dict, kbid: str, rid: str, field_id: str
) -> BrokerMessage:
    from unittest.mock import AsyncMock

    from nucliadb_utils.utilities import Utility, set_utility

    set_utility(Utility.STORAGE, AsyncMock())

    bm = BrokerMessage(
        kbid=kbid,
        uuid=rid,
        source=BrokerMessage.MessageSource.PROCESSOR,
        file_extracted_data=[
            FileExtractedData(
                field=field_id,
                file_pages_previews=FilePages(
                    pages=[
                        CloudFile(),
                    ],
                    structures=[
                        PageStructure(
                            page=PageStructurePage(width=10, height=10),
                            tokens=[
                                PageStructureToken(
                                    x=token["x"],
                                    y=token["y"],
                                    width=token["width"],
                                    height=token["height"],
                                    text=token["text"],
                                    line=0,
                                )
                                for token in selections["tokens"]
                            ],
                        )
                    ],
                ),
            )
        ],
    )

    return bm
