from nats.aio.msg import Msg as Msg
from nats.aio.subscription import Subscription as Subscription
from nats.js import api as api
from nats.js.headers import LAST_CONSUMER_SEQ_HDR as LAST_CONSUMER_SEQ_HDR
from nats.js.kv import KeyValueManager as KeyValueManager
from nats.js.manager import JetStreamManager as JetStreamManager
from typing import Any, Awaitable, Callable, Optional

NATS_HDR_LINE: Any
NATS_HDR_LINE_SIZE: Any

class JetStreamContext(JetStreamManager, KeyValueManager):
    def __init__(self, conn, prefix: str = ..., domain: Optional[str] = ..., timeout: float = ...) -> None: ...
    async def publish(self, subject: str, payload: bytes = ..., timeout: float = ..., stream: str = ..., headers: dict = ...) -> api.PubAck: ...
    async def subscribe(self, subject: str, queue: Optional[str] = ..., cb: Optional[Callable[[Msg], Awaitable[None]]] = ..., durable: Optional[str] = ..., stream: Optional[str] = ..., config: Optional[api.ConsumerConfig] = ..., manual_ack: Optional[bool] = ..., ordered_consumer: Optional[bool] = ..., idle_heartbeat: Optional[float] = ..., flow_control: Optional[bool] = ...) -> Subscription: ...
    async def pull_subscribe(self, subject: str, durable: str, stream: str = ..., config: api.ConsumerConfig = ...): ...
    async def pull_subscribe_bind(self, subject: str, durable: str, stream: str = ...): ...
    @classmethod
    def is_status_msg(cls, msg): ...
    class _JSI:
        def __init__(self, js: JetStreamContext, conn, stream, ordered, psub, sub, ccreq) -> None: ...
        def track_sequences(self, reply) -> None: ...
        def schedule_flow_control_response(self, reply) -> None: ...
        async def check_for_sequence_mismatch(self, msg): ...
        async def reset_ordered_consumer(self, sseq) -> bool: ...
        async def recreate_consumer(self) -> None: ...
    class PushSubscription(Subscription):
        def __init__(self, js, sub, stream, consumer) -> None: ...
        async def consumer_info(self): ...
    class PullSubscription:
        def __init__(self, js, sub, stream, consumer, deliver) -> None: ...
        async def unsubscribe(self) -> None: ...
        async def consumer_info(self): ...
        async def fetch(self, batch: int = ..., timeout: int = ...): ...
    async def get_last_msg(self, stream_name: str, subject: str): ...
    class _JS:
        def __init__(self, conn: Any | None = ..., prefix: Any | None = ..., stream: Any | None = ..., consumer: Any | None = ..., nms: Any | None = ...) -> None: ...
